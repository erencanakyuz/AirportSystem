@{
    Layout = null;
}
<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <title>İstanbul Havalimanı Radarı</title>
    <style>
        /* A full-screen dark background with a centered canvas */
        body, html {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
        }

        #radarCanvas {
            display: block;
            margin: 0 auto;
            background: radial-gradient(ellipse at center, #010, #000);
        }
    </style>
</head>
<body>
    <!-- The radar canvas -->
    <canvas id="radarCanvas" width="600" height="600"></canvas>

    <!-- GSAP is included in case you want to enhance animations further -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script>
    // --- Canvas Setup ---
    const canvas = document.getElementById('radarCanvas');
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    const centerX = width / 2;
    const centerY = height / 2;
    // Leave some padding so the radar circles don’t touch the edge.
    const radarRadius = Math.min(width, height) / 2 - 20;

    let sweepAngle = 0;
    let flightData = []; // This will hold our flight data array

    // --- Draw Radar Background ---
    function drawRadarBackground() {
      ctx.clearRect(0, 0, width, height);

      // Outer circle
      ctx.strokeStyle = '#0f0';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(centerX, centerY, radarRadius, 0, Math.PI * 2);
      ctx.stroke();

      // Concentric circles
      ctx.lineWidth = 1;
      for (let i = 1; i <= 4; i++) {
        ctx.beginPath();
        ctx.arc(centerX, centerY, (radarRadius / 4) * i, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Radial lines every 30°
      for (let i = 0; i < 360; i += 30) {
        let rad = i * Math.PI / 180;
        let x = centerX + radarRadius * Math.cos(rad);
        let y = centerY + radarRadius * Math.sin(rad);
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(x, y);
        ctx.stroke();
      }
    }

    // --- Draw the Sweeping Radar Beam ---
    function drawSweep() {
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(sweepAngle);

      // Create a radial gradient for a glowing effect
      let grad = ctx.createRadialGradient(0, 0, 0, 0, 0, radarRadius);
      grad.addColorStop(0, "rgba(0,255,0,0.4)");
      grad.addColorStop(1, "rgba(0,255,0,0)");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      // A narrow wedge for the sweep (adjust the angle as needed)
      ctx.arc(0, 0, radarRadius, -0.03, 0.03);
      ctx.lineTo(0, 0);
      ctx.fill();
      ctx.restore();
    }

    // --- Convert Geographic Coordinates to Canvas Coordinates ---
    // For the demo we assume:
    // Istanbul Airport region approx: lat [40.8, 41.1] and lon [28.7, 28.9].
    const latMin = 40.8, latMax = 41.1, lonMin = 28.7, lonMax = 28.9;
    function geoToCanvas(lat, lon) {
      // Normalize to a 0–1 range
      let normX = (lon - lonMin) / (lonMax - lonMin);
      let normY = 1 - (lat - latMin) / (latMax - latMin); // Invert Y because canvas y grows downward

      // Map normalized coordinates to canvas points relative to the center.
      // Here we assume the radar circle covers the entire defined region.
      let x = centerX + (normX - 0.5) * radarRadius * 2;
      let y = centerY + (normY - 0.5) * radarRadius * 2;
      return { x, y };
    }

    // --- Draw Flight Markers as Blinking Dots ---
    function drawFlights(time) {
      flightData.forEach(flight => {
        // OpenSky API: flight[5] = longitude, flight[6] = latitude.
        let lon = flight[5], lat = flight[6];
        if (lon == null || lat == null) return;
        let pos = geoToCanvas(lat, lon);

        // Only draw if within the radar circle
        let dx = pos.x - centerX, dy = pos.y - centerY;
        if (Math.sqrt(dx * dx + dy * dy) > radarRadius) return;

        // Create a blinking effect using a sine wave based on time.
        // (flight[0] is used to add variation among different planes)
        let blink = (Math.sin(time / 200 + flight[0]) + 1) / 2;
        let dotRadius = 4 + blink * 2;

        ctx.beginPath();
        ctx.arc(pos.x, pos.y, dotRadius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0,255,0,0.8)';
        ctx.fill();

       
         ctx.fillStyle = "#0f0";
         ctx.font = "10px Arial";
         let callsign = flight[1] ? flight[1].trim() : "N/A";
        ctx.fillText(callsign, pos.x + 6, pos.y);
      });
    }

    // --- Animation Loop ---
    function animate(time) {
      drawRadarBackground();
      drawSweep();
      drawFlights(time);
      // Increase the sweep angle so that a full rotation occurs in about 3 seconds.
      sweepAngle = (time / 3000 * 2 * Math.PI) % (2 * Math.PI);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // --- Flight Data Fetching ---
    // Poll the server every 15 seconds. (Replace with SignalR for real-time updates if desired.)
    async function fetchFlightData() {
      try {
        const response = await fetch('@Url.Action("GetFlights", "Radar")');
        if (response.ok) {
          const data = await response.json();
          if (data.states) {
            flightData = data.states;
          }
        }
      } catch (err) {
        console.error('Error fetching flight data', err);
      }
    }
    // Initial fetch and then poll every 15 sec.
    fetchFlightData();
    setInterval(fetchFlightData, 15000);
    </script>
</body>
</html>
